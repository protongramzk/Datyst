const LS_CHARSET="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 #@<>{}[]+-*/",LS_TO_INDEX=new Int8Array(128).fill(-1);for(let t=0;t<49;t++)LS_TO_INDEX[LS_CHARSET.charCodeAt(t)]=t;class LiteString{constructor(t,e){const s=e.length,r=t.n(2+s);t.u16(r,s);for(let n=0;n<s;n++){const s=e.charCodeAt(n),i=LS_TO_INDEX[s];if(-1===i)throw new Error("Unsupported char: "+e[n]);t.u8(r+2+n,i)}this.u8=t,this.ptr=r,this.length=s}static fromPtr(t,e){const s=t.b[e]|t.b[e+1]<<8,r=Object.create(LiteString.prototype);return r.u8=t,r.ptr=e,r.length=s,r}charAt(t){return LS_CHARSET[this.u8.b[this.ptr+2+t]]}toString(){const t=this.length;let e="";const s=this.u8.b,r=this.ptr+2;for(let n=0;n<t;n++)e+=LS_CHARSET[s[r+n]];return e}equals(t){if(this.length!==t.length)return!1;const e=this.u8.b,s=t.u8.b,r=this.ptr+2,n=t.ptr+2;for(let t=0;t<this.length;t++)if(e[r+t]!==s[n+t])return!1;return!0}hash(){let t=2166136261;const e=this.u8.b,s=this.ptr+2;for(let r=0;r<this.length;r++)t^=e[s+r],t+=(t<<1)+(t<<4)+(t<<7)+(t<<8)+(t<<24);return t>>>0}}class ui8{constructor(t=1024){this.b=new Uint8Array(t),this.t=0}n(t){let e=this.t,s=e+t;if(s>this.b.length){let t=this.b.length<<1;for(;t<s;)t<<=1;const e=new Uint8Array(t);e.set(this.b),this.b=e}return this.t=s,e}u8(t,e){this.b[t]=e}u16(t,e){const s=this.b;s[t]=255&e,s[t+1]=e>>>8}u32(t,e){const s=this.b;s[t]=255&e,s[t+1]=e>>>8&255,s[t+2]=e>>>16&255,s[t+3]=e>>>24}copy(t,e,s){this.b.set(e.subarray(0,s),t)}}class SmallFloat{constructor(t=0){this.val=t}set(t){this.val=t}get(){return this.val}toBytes(){let t=Math.round(256*this.val);return t<-32768&&(t=-32768),t>32767&&(t=32767),Uint8Array.from([255&t,t>>8&255])}static fromBytes(t){let e=t[0]|t[1]<<8;return 32768&e&&(e-=65536),new SmallFloat(e/256)}}class ConfObject{constructor(t={}){this.entries=[],this.index=new Map,this.dataMap=t;for(const e in t){const s=t[e];this.set(e,s)}}set(t,e){this.entries.push([t,e]),this.index[t]=e}get(t){return this.index[t]}resolve(t,e){let s=this.get(t);return"string"==typeof s&&e&&e[s]?e[s]:s}}class SuperUI8{constructor(t=1024){this.buffer=new Uint8Array(t),this.length=0}_ensure(t){const e=this.length+t;if(e>this.buffer.length){let t=this.buffer.length<<1;for(;t<e;)t<<=1;const s=new Uint8Array(t);s.set(this.buffer),this.buffer=s}}push(t){if(t<0)throw new Error("Only non-negative numbers supported");const e=[];do{e.push(255&t),t>>=8}while(t>0);this._ensure(e.length);for(let t=0;t<e.length;t++)this.buffer[this.length++]=e[t];return this.length-e.length}get(t){let e=0,s=0,r=t;for(;r<this.length;){const t=this.buffer[r++];if(e+=t<<s,s+=8,t<255)break}return{value:e,nextIndex:r}}set(t,e){const s=[];do{s.push(255&e),e>>=8}while(e>0);for(let e=0;e<s.length;e++)this.buffer[t+e]=s[e]}toBytes(){return this.buffer.slice(0,this.length)}clear(){this.length=0}}class Flags{constructor(t=1){this.buffer=new Uint8Array(t)}_ensure(t){const e=Math.floor(t/8)+1;if(e>this.buffer.length){let t=this.buffer.length;for(;t<e;)t<<=1;const s=new Uint8Array(t);s.set(this.buffer),this.buffer=s}}set(t){this._ensure(t);const e=Math.floor(t/8),s=t%8;this.buffer[e]|=1<<s}clear(t){this._ensure(t);const e=Math.floor(t/8),s=t%8;this.buffer[e]&=~(1<<s)}toggle(t){this._ensure(t);const e=Math.floor(t/8),s=t%8;this.buffer[e]^=1<<s}check(t){this._ensure(t);const e=Math.floor(t/8),s=t%8;return 0!=(this.buffer[e]&1<<s)}clearAll(){this.buffer.fill(0)}toBytes(){return this.buffer.slice()}fromBytes(t){this.buffer=new Uint8Array(t)}get length(){return 8*this.buffer.length}getFlag(t){return this.check(t)}setFlag(t,e){e?this.set(t):this.clear(t)}}class SConfObject{constructor(){this.keys=[],this.values=[]}set(t,e){if(!(t instanceof LiteString))throw new Error("Key must be LiteString");const s=this.keys.findIndex((e=>e.toString()===t.toString()));s>=0?this.values[s]=e:(this.keys.push(t),this.values.push(e))}get(t){const e=this.keys.findIndex((e=>e.toString()===t.toString()));return e>=0?this.values[e]:null}has(t){return this.keys.some((e=>e.toString()===t.toString()))}forEach(t){for(let e=0;e<this.keys.length;e++)t(this.keys[e],this.values[e])}toBytes(){const t=[];for(let e=0;e<this.keys.length;e++){const s=this.keys[e].toBytes();t.push(s.length),t.push(...s);const r=this.values[e];if(r instanceof SmallFloat){t.push(0);const e=r.toBytes();t.push(...e)}else if(r instanceof ui8||r instanceof SuperUI8){t.push(1);const e=r.toBytes();t.push(255&e.length,e.length>>8&255),t.push(...e)}else if(r instanceof LiteString){t.push(2);const e=r.toBytes();t.push(255&e.length,e.length>>8&255),t.push(...e)}else{if(!(r instanceof Flags))throw new Error("Unsupported value type");{t.push(3);const e=r.toBytes();t.push(e.length),t.push(...e)}}}return new Uint8Array(t)}static fromBytes(t){const e=new SConfObject;let s=0;for(;s<t.length;){const r=t[s++],n=t.slice(s,s+r),i=LiteString.fromBytes(n);s+=r;const h=t[s++];if(0===h){const r=t.slice(s,s+2),n=SmallFloat.fromBytes(r);s+=2,e.set(i,n)}else if(1===h){const r=t[s]|t[s+1]<<8;s+=2;const n=t.slice(s,s+r),h=SuperUI8.fromBytes(n);s+=r,e.set(i,h)}else if(2===h){const r=t[s]|t[s+1]<<8;s+=2;const n=t.slice(s,s+r),h=LiteString.fromBytes(n);s+=r,e.set(i,h)}else if(3===h){const r=t[s++],n=t.slice(s,s+r),h=new Flags;h.fromBytes(n),s+=r,e.set(i,h)}}return e}}